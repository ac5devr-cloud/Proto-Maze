<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0"> 
    <title>PROTO MAZE v3.3 - AUDIO ENABLED</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; touch-action: none; user-select: none; -webkit-user-select: none; }
        :root {
            --proto-color: #00f3ff;
            --proto-dim: rgba(0, 243, 255, 0.2);
            --danger-color: #ff0040;
        }
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
            display: flex; flex-direction: column; justify-content: space-between; 
            padding: 30px; box-sizing: border-box; 
            z-index: 10;
        }
        #visor-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,20,40,0.6) 90%, #000 100%);
            box-shadow: inset 0 0 80px var(--proto-dim);
        }
        #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 6;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 255, 255, 0.05) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 4px, 6px 100%;
            opacity: 0.8;
        }
        .hud-text { 
            color: var(--proto-color); 
            text-shadow: 0 0 5px var(--proto-color); 
            font-size: 20px; 
            font-weight: bold; 
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        #minimap-container {
            position: relative;
            border: 2px solid var(--proto-color);
            background: rgba(0, 20, 30, 0.7);
            border-radius: 10px 0 10px 0;
            box-shadow: 0 0 15px var(--proto-dim);
            padding: 5px;
            display: none; 
        }
        #logo-container {
            display: none; 
            text-align: right;
            border: 2px solid var(--proto-color);
            background: rgba(0, 20, 30, 0.7);
            border-radius: 10px 0 10px 0;
            box-shadow: 0 0 15px var(--proto-dim);
            padding: 10px 15px;
        }
        #logo-container .div-name {
            font-size: 14px; color: var(--proto-color); opacity: 0.8; letter-spacing: 3px; margin-bottom: 5px;
        }
        #logo-container .div-logo {
            font-size: 24px; color: #fff; text-shadow: 0 0 10px var(--proto-color); line-height: 1;
        }
        .status-area { display: flex; flex-direction: column; gap: 10px; }
        .status-bar {
            display: flex; align-items: center; gap: 15px;
            background: linear-gradient(90deg, transparent, rgba(0, 243, 255, 0.1), transparent);
            padding: 5px 10px;
        }
        .bar-segment {
            height: 10px; width: 40px;
            background: var(--proto-color);
            box-shadow: 0 0 8px var(--proto-color);
            transform: skewX(-20deg);
            opacity: 0.8;
            transition: opacity 0.2s, background 0.1s linear;
        }
        #center-info { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            text-align: center; color: white; 
            background: rgba(0, 10, 15, 0.95); 
            padding: 40px; 
            border: 1px solid var(--proto-color); 
            box-shadow: 0 0 30px var(--proto-dim), inset 0 0 20px var(--proto-dim);
            pointer-events: auto; 
            z-index: 20;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }
        .proto-btn {
            background: rgba(0, 243, 255, 0.1);
            border: 2px solid var(--proto-color);
            color: var(--proto-color);
            padding: 15px 30px;
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s;
            box-shadow: 0 0 10px var(--proto-dim);
            text-transform: uppercase;
        }
        .proto-btn:hover { background: var(--proto-color); color: #000; box-shadow: 0 0 20px var(--proto-color); }
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; 
            transform: translate(-50%, -50%); pointer-events: none; z-index: 15;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: var(--proto-color); box-shadow: 0 0 5px var(--proto-color);
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        .phasing #visor-overlay {
            box-shadow: inset 0 0 100px rgba(0, 255, 100, 0.5);
            background: radial-gradient(circle, rgba(0,255,100,0.1) 0%, rgba(0,20,40,0.6) 90%, #000 100%);
        }
        .phasing .hud-text, .phasing .bar-segment { filter: hue-rotate(90deg); }
        .hidden { display: none !important; }
        kbd { border: 1px solid var(--proto-color); color: var(--proto-color); padding: 2px 6px; box-shadow: 0 0 5px var(--proto-dim); background: transparent; font-size: 0.9em;}
        
        #mobile-controls {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 12; pointer-events: none; display: none; 
        }
        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: block; }
            .status-area .hud-text { display: none; } 
            #mobile-top-ui { display: flex !important; }
        }
        .joy-zone {
            position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px;
            background: rgba(0, 243, 255, 0.1); border: 2px solid rgba(0, 243, 255, 0.3);
            border-radius: 50%; pointer-events: auto; touch-action: none;
        }
        .joy-knob {
            position: absolute; top: 50%; left: 50%; width: 60px; height: 60px;
            background: rgba(0, 243, 255, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); box-shadow: 0 0 15px var(--proto-color); pointer-events: none;
        }
        .mobile-btn-container {
            position: absolute; bottom: 60px; right: 40px; display: flex; flex-direction: column; gap: 20px; pointer-events: auto;
        }
        .mob-btn {
            width: 70px; height: 70px; background: rgba(0, 20, 30, 0.6);
            border: 2px solid var(--proto-color); border-radius: 50%; color: var(--proto-color);
            font-weight: bold; font-size: 14px; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 10px var(--proto-dim); touch-action: manipulation; user-select: none; pointer-events: auto;
        }
        .mob-btn:active { background: var(--proto-color); color: #000; }

        #mobile-top-ui {
            position: absolute; top: 20px; right: 20px; left: 20px;
            display: none; justify-content: space-between; pointer-events: none; z-index: 25;
        }
        .mini-btn {
            width: 40px; height: 40px; background: rgba(0, 243, 255, 0.1);
            border: 2px solid var(--proto-color); color: var(--proto-color);
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; pointer-events: auto; cursor: pointer;
            box-shadow: 0 0 10px var(--proto-dim);
        }
        .mini-btn:active, .mini-btn:hover { background: var(--proto-color); color: #000; }

        #settings-panel {
            display: none; flex-direction: column; gap: 15px; margin-top: 20px; text-align: left;
            border-top: 1px solid var(--proto-dim); padding-top: 20px;
        }
        .setting-row { display: flex; justify-content: space-between; align-items: center; }
        input[type=range] { width: 100px; accent-color: var(--proto-color); }
        input[type=checkbox] { accent-color: var(--proto-color); width: 20px; height: 20px; }

        #controls-hint {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: var(--proto-color); font-size: 14px; opacity: 0.7; z-index: 10;
        }
        #controls-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 15, 20, 0.95); border: 2px solid var(--proto-color);
            padding: 30px; z-index: 50; display: none; text-align: center;
            box-shadow: 0 0 40px var(--proto-dim);
        }
    </style>
</head>
<body>
    <audio id="game-music" loop style="display:none;">
        <source src="proto_maze.mp3" type="audio/mpeg">
    </audio>

    <div id="mobile-top-ui">
        <div style="flex:1;"></div>
        <div class="mini-btn" id="mob-pause-btn" style="margin-right: auto; margin-left: auto;">||</div>
        <div style="flex:1; display:flex; justify-content: flex-end; gap: 10px;">
            <div class="mini-btn" id="fullscreen-btn">&#x26F6;</div>
        </div>
    </div>

    <div id="controls-modal">
        <h2 style="color:var(--proto-color); margin-bottom:20px;">// SYSTEM CONTROLS //</h2>
        <div style="text-align: left; line-height: 2em; color: #fff;">
            <p><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> - MOVE</p>
            <p><kbd>SPACE</kbd> - JUMP</p>
            <p><kbd>SHIFT</kbd> - PHASE SHIFT (DASH)</p>
            <p><kbd>O</kbd> - FULLSCREEN</p>
            <p><kbd>ESC</kbd> - PAUSE</p>
            <p><kbd>I</kbd> - CLOSE THIS MENU</p>
        </div>
        <button id="close-controls-btn" class="proto-btn" style="margin-top:20px;">ACKNOWLEDGE</button>
    </div>

    <div id="visor-overlay"></div>
    <div id="scanlines"></div>
    <div id="crosshair"></div>

    <div id="ui-layer">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
            <div>
                <div class="hud-text" id="level-display">ZONE: 1</div>
                <div style="font-size:12px; color:cyan; opacity:0.6;">/// ROGUE PROTOCOL ///</div>
                <div class="hud-text" id="timer-display" style="font-size: 16px; opacity: 0.8; margin-top: 10px;">TIME: 00:00.000</div>
                <div class="hud-text" id="highscore-display" style="font-size: 16px; opacity: 0.8; margin-top: 5px;">HIGH: ZONE 1</div>
            </div>
            <div id="minimap-container">
                <canvas id="minimap" width="150" height="150"></canvas>
            </div>
            <div id="logo-container">
                <div class="div-name">PRIME FOX RESEARCH DIVISION</div>
                <div class="div-logo"><span style="color: var(--danger-color);">P</span><span style="color: white;">/F</span></div>
            </div>
        </div>
        <div class="status-area">
            <div class="status-bar">
                <div class="hud-text" style="font-size: 12px;">PHASE:</div>
                <div class="bar-segment" id="bar-seg-1"></div>
                <div class="bar-segment" id="bar-seg-2"></div>
                <div class="bar-segment" id="bar-seg-3"></div>
            </div>
        </div>
        <div id="controls-hint">[ I - CONTROLS ]</div>
    </div>

    <div id="mobile-controls">
        <div class="joy-zone" id="joy-base"><div class="joy-knob" id="joy-stick"></div></div>
        <div class="mobile-btn-container">
            <div class="mob-btn" id="btn-jump">JUMP</div>
            <div class="mob-btn" id="btn-dash">PHASE</div>
        </div>
    </div>

    <div id="center-info">
        <h1 style="margin:0 0 10px 0; color: #00f3ff; text-shadow: 0 0 15px cyan; font-size: 3em;">PROTO MAZE</h1>
        <p style="font-family: monospace;">> Initialize Neural Link...</p>
        <br>
        <button id="start-btn" class="proto-btn">START SYSTEM</button>
        <button id="settings-btn" class="proto-btn" style="margin-left: 10px;">SETTINGS</button>

        <div id="settings-panel">
            <div class="setting-row">
                <span>SENSITIVITY: <span id="sens-val">1.0</span></span>
                <input type="range" id="sens-input" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>
            <div class="setting-row">
                <span>LOW QUALITY:</span>
                <input type="checkbox" id="gfx-input">
            </div>
            <div class="setting-row" style="justify-content: center; margin-top: 10px;">
                <button id="close-settings-btn" class="proto-btn" style="padding: 10px 20px; font-size: 1em;">BACK</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const CONFIG = {
            // !!! DEV MINIMAP TOGGLE !!!
            // Set this to TRUE to see the map on level 1.
            DEV_SHOW_MINIMAP: false, 
            
            wallHeight: 3.5, cellSize: 3.0, walkSpeed: 6.0, playerRadius: 0.4,
            jumpForce: 6.0, gravity: 15.0, viewBobSpeed: 12, viewBobHeight: 0.1,
            dodgeDuration: 0.4, dashForce: 15.0, dashTime: 0.2,
            dashRechargeTime: 4.0, maxDashCharges: 3,
            FALL_HEIGHT: -15.0 
        };
        
        let scene, camera, renderer, controls;
        let walls = [], enemies = [], goalObj = null;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false; 
        let velocityY = 0;
        let gameStartTime = 0;
        let isGameRunning = false;
        let isPaused = false;
        let highScore = localStorage.getItem('protoMazeHighScore') || 1;
        let isDodging = false;
        let dodgeTimer = 0, dashTimer = 0;
        let dashCharges = 3;
        let dashRechargeTimer = 0;
        let barSegments = [];
        let dashVector = new THREE.Vector3();
        let prevTime = performance.now();
        let direction = new THREE.Vector3();
        let level = 1;
        let mazeWidth = 0, mazeHeight = 0;
        let grid = [];
        let bobTimer = 0;
        const defaultCameraHeight = 1.6;
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        let joystick = { x: 0, y: 0 };
        let joyTouchId = -1;
        let isMobile = false;
        let lookSpeed = 1.5;
        let isLooking = false; 
        let gamepadIndex = null;
        const GAMEPAD_DEADZONE = 0.15; 
        const GAMEPAD_LOOK_SPEED = 0.05; 
        let prevGamepadState = {}; 

        let isControlsModalOpen = false;
        let sensitivity = 1.0;
        let lowGraphics = false;
        
        const playerCollider = new THREE.Box3();
        let gameMusic;

        function formatTime(ms) {
            const m = Math.floor(ms / 60000);
            const s = Math.floor((ms % 60000) / 1000);
            const mi = ms % 1000;
            return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(mi).padStart(3,'0')}`;
        }

        init();
        animate(performance.now());

        // --- RANDOM MAZE GENERATION ---
        function createRandomMaze(w, h) {
            // Ensure odd dimensions
            const width = w % 2 === 0 ? w + 1 : w;
            const height = h % 2 === 0 ? h + 1 : h;
            
            // Fill with walls
            const map = [];
            for(let y=0; y<height; y++) {
                let row = [];
                for(let x=0; x<width; x++) row.push('#');
                map.push(row);
            }

            // Recursive Backtracker
            const stack = [];
            const startX = 1;
            const startY = 1;
            map[startY][startX] = '.';
            stack.push({x: startX, y: startY});

            const dirs = [
                {x: 0, y: -2}, // N
                {x: 0, y: 2},  // S
                {x: 2, y: 0},  // E
                {x: -2, y: 0}  // W
            ];

            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            while(stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];

                shuffle(dirs);
                
                for(let d of dirs) {
                    const nx = current.x + d.x;
                    const ny = current.y + d.y;
                    if(nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1) {
                        if(map[ny][nx] === '#') {
                            neighbors.push({x: nx, y: ny, dx: d.x/2, dy: d.y/2});
                        }
                    }
                }

                if(neighbors.length > 0) {
                    const next = neighbors[0];
                    map[next.y][next.x] = '.';
                    map[current.y + next.dy][current.x + next.dx] = '.'; // Carve wall between
                    stack.push({x: next.x, y: next.y});
                } else {
                    stack.pop();
                }
            }

            // Place Player
            map[1][1] = 'P';

            // Place Goal (simple logic: random empty spot far from start, or bottom right area)
            let goalPlaced = false;
            for(let y = height-2; y > height/2; y--) {
                for(let x = width-2; x > width/2; x--) {
                    if(map[y][x] === '.') {
                        map[y][x] = 'G';
                        goalPlaced = true;
                        break;
                    }
                }
                if(goalPlaced) break;
            }
            if(!goalPlaced) map[height-2][width-2] = 'G'; // Fallback

            return map;
        }

        function generateTexture(color, type = 'grid') {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color; ctx.fillRect(0,0,512,512);
            if (type === 'grid') {
                ctx.strokeStyle = '#004444'; ctx.lineWidth = 4;
                ctx.strokeRect(0,0,512,512); ctx.fillStyle = '#001111'; ctx.fillRect(10,10, 492, 492);
            } else if (type === 'brick') {
                ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0,0,512,512);
                ctx.strokeStyle = '#00f3ff'; ctx.lineWidth = 2;
                for(let y=0;y<512;y+=64) for(let x=0;x<512;x+=64) {
                    ctx.strokeRect(x,y,64,64); if(Math.random()>0.8) { ctx.fillStyle = 'rgba(0, 243, 255, 0.2)'; ctx.fillRect(x+4,y+4,56,56); }
                }
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; return tex;
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{});
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        function toggleControlsModal(forceState = null) {
            const modal = document.getElementById('controls-modal');
            const newState = forceState !== null ? forceState : (modal.style.display === 'none' || modal.style.display === '');
            
            if (newState) {
                modal.style.display = 'block';
                isControlsModalOpen = true;
                if(!isPaused && !isMobile) controls.unlock();
            } else {
                modal.style.display = 'none';
                isControlsModalOpen = false;
                if(isGameRunning && !isPaused && !isMobile) controls.lock(); 
            }
        }

        // RESET MOVEMENT FLAGS TO PREVENT BUG
        function resetInputs() {
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
        }

        function requestPause() {
            if (!isMobile) controls.unlock(); // This triggers the 'unlock' event which handles UI and Resets inputs
            else {
                isPaused = true;
                resetInputs(); // Manually reset for mobile if needed
                if(gameMusic) gameMusic.pause();
                const centerInfo = document.getElementById('center-info');
                centerInfo.classList.remove('hidden');
                document.getElementById('start-btn').innerText = "RESUME";
            }
        }

        function requestResume() {
            if (!isMobile) controls.lock(); // This triggers the 'lock' event which handles UI
            else {
                isPaused = false;
                if(gameMusic) gameMusic.play().catch(e=>console.log(e));
                document.getElementById('center-info').classList.add('hidden');
            }
        }

        function applySettings() {
            if (controls) controls.pointerSpeed = sensitivity;
            
            if (lowGraphics) {
                renderer.shadowMap.enabled = false;
                renderer.setPixelRatio(0.8);
                document.getElementById('scanlines').style.display = 'none';
            } else {
                renderer.shadowMap.enabled = true;
                renderer.setPixelRatio(window.devicePixelRatio);
                document.getElementById('scanlines').style.display = 'block';
            }
            
            scene.traverse(obj => {
                if (obj.isMesh && obj.material) obj.material.needsUpdate = true;
            });
        }

        function updateDashUI() {
            for (let i = 0; i < CONFIG.maxDashCharges; i++) {
                if (i < dashCharges) {
                    barSegments[i].style.opacity = 0.8;
                    barSegments[i].style.background = 'var(--proto-color)';
                } else {
                    barSegments[i].style.opacity = 0.3;
                    barSegments[i].style.background = 'rgba(0,0,0,0.5)';
                }
            }
            
            if (dashCharges < CONFIG.maxDashCharges) {
                const progress = 1.0 - (dashRechargeTimer / CONFIG.dashRechargeTime);
                barSegments[dashCharges].style.opacity = 0.8;
                barSegments[dashCharges].style.background = `linear-gradient(to right, var(--proto-color) ${progress * 100}%, rgba(0,0,0,0.5) ${progress * 100}%)`;
            }
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 150);
            camera.position.y = defaultCameraHeight; camera.rotation.order = 'YXZ';

            const ambientLight = new THREE.AmbientLight(0x404040); scene.add(ambientLight);
            const flashLight = new THREE.SpotLight(0xaaffff, 4.0);
            flashLight.position.set(0.3, -0.3, 0); flashLight.angle = Math.PI / 5; flashLight.penumbra = 0.5; flashLight.distance = 40;
            flashLight.castShadow = true; camera.add(flashLight);
            const targetObj = new THREE.Object3D(); targetObj.position.set(0, 0, -5); camera.add(targetObj); flashLight.target = targetObj;
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            
            regenerateLevel();
            
            const instructions = document.getElementById('center-info');
            const startBtn = document.getElementById('start-btn');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const settingsBtn = document.getElementById('settings-btn');
            const settingsPanel = document.getElementById('settings-panel');
            const sensInput = document.getElementById('sens-input');
            const gfxInput = document.getElementById('gfx-input');
            const closeSettingsBtn = document.getElementById('close-settings-btn');
            
            gameMusic = document.getElementById('game-music');
            gameMusic.volume = 0.5;

            barSegments = [
                document.getElementById('bar-seg-1'),
                document.getElementById('bar-seg-2'),
                document.getElementById('bar-seg-3')
            ];
            updateDashUI();

            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            fullscreenBtn.addEventListener('click', toggleFullscreen);

            settingsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                settingsPanel.style.display = 'flex';
                startBtn.style.display = 'none';
                settingsBtn.style.display = 'none';
            });

            closeSettingsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                settingsPanel.style.display = 'none';
                startBtn.style.display = 'inline-block';
                settingsBtn.style.display = 'inline-block';
            });

            sensInput.addEventListener('input', (e) => {
                sensitivity = parseFloat(e.target.value);
                document.getElementById('sens-val').innerText = sensitivity.toFixed(1);
                applySettings();
            });

            gfxInput.addEventListener('change', (e) => {
                lowGraphics = e.target.checked;
                applySettings();
            });

            const startGameHandler = (e) => {
                if (e && e.cancelable) e.preventDefault();
                
                // --- ATTEMPT AUDIO START ---
                if(gameMusic && gameMusic.paused) {
                    gameMusic.play().catch(err => console.log("Audio autoplay prevented", err));
                }

                if (isPaused) { requestResume(); return; }
                
                if (!isMobile) controls.lock();
                else {
                    instructions.classList.add('hidden');
                    if (!isGameRunning) { gameStartTime = performance.now(); isGameRunning = true; }
                    setupMobileControls();
                }
            };

            startBtn.addEventListener('click', startGameHandler);
            if (isMobile) startBtn.addEventListener('touchstart', startGameHandler, {passive: false});

            // --- FIXED CONTROLS / PAUSE LOGIC ---
            controls.addEventListener('lock', () => {
                instructions.classList.add('hidden');
                isPaused = false;
                if(gameMusic) gameMusic.play().catch(e=>{}); // Resume music
                isControlsModalOpen = false;
                document.getElementById('controls-modal').style.display = 'none';
                if (!isGameRunning) { gameStartTime = performance.now(); isGameRunning = true; }
            });

            controls.addEventListener('unlock', () => {
                resetInputs(); // CRITICAL FIX: Reset WASD flags when pausing
                if(!isMobile && isGameRunning) {
                    isPaused = true;
                    if(gameMusic) gameMusic.pause(); // Pause music
                    instructions.classList.remove('hidden');
                    startBtn.innerText = "RESUME";
                    settingsPanel.style.display = 'none';
                    startBtn.style.display = 'inline-block';
                    settingsBtn.style.display = 'inline-block';
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.code === 'KeyO') { toggleFullscreen(); }
                if (e.code === 'KeyI') { toggleControlsModal(); }

                if (!isPaused && isGameRunning) {
                    switch (e.code) {
                        case 'ArrowUp': case 'KeyW': moveForward = true; break;
                        case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                        case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                        case 'ArrowRight': case 'KeyD': moveRight = true; break;
                        case 'Space': if (canJump) { velocityY = CONFIG.jumpForce; canJump = false; } break;
                        case 'ShiftLeft': case 'ShiftRight': tryDodge(); break;
                    }
                }
            });
            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                }
            });
            
            document.getElementById('close-controls-btn').addEventListener('click', () => toggleControlsModal(false));

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.getElementById('highscore-display').innerText = `HIGH: ZONE ${highScore}`;
            
            window.addEventListener("gamepadconnected", (e) => { if (gamepadIndex === null) gamepadIndex = e.gamepad.index; });
            window.addEventListener("gamepaddisconnected", (e) => { if (gamepadIndex === e.gamepad.index) gamepadIndex = null; });
        }
        
        function handleGamepadInput(delta) {
            if (gamepadIndex === null) return;
            const gamepad = navigator.getGamepads()[gamepadIndex];
            if (!gamepad) return;

            const lsX = gamepad.axes[0], lsY = gamepad.axes[1];
            if (Math.sqrt(lsX * lsX + lsY * lsY) > GAMEPAD_DEADZONE) { joystick.x = lsX; joystick.y = -lsY; }
            else { joystick.x = 0; joystick.y = 0; }
            
            const rsX = gamepad.axes[2], rsY = gamepad.axes[3];
            if (Math.abs(rsX) > GAMEPAD_DEADZONE) camera.rotation.y -= rsX * GAMEPAD_LOOK_SPEED * sensitivity;
            if (Math.abs(rsY) > GAMEPAD_DEADZONE) {
                camera.rotation.x -= rsY * GAMEPAD_LOOK_SPEED * sensitivity;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
            
            if (gamepad.buttons[0]?.pressed && !prevGamepadState['btn0'] && canJump) { velocityY = CONFIG.jumpForce; canJump = false; }
            if (gamepad.buttons[1]?.pressed && !prevGamepadState['btn1']) tryDodge();
            
            if (gamepad.buttons[9]?.pressed && !prevGamepadState['btn9']) {
                if(isControlsModalOpen) {
                    toggleControlsModal(false);
                } else if (isGameRunning) {
                    if(isPaused) requestResume(); else requestPause();
                }
            }

            prevGamepadState['btn0'] = gamepad.buttons[0]?.pressed;
            prevGamepadState['btn1'] = gamepad.buttons[1]?.pressed;
            prevGamepadState['btn9'] = gamepad.buttons[9]?.pressed;
        }

        function setupMobileControls() {
            const joyBase = document.getElementById('joy-base');
            const joyStick = document.getElementById('joy-stick');
            const btnJump = document.getElementById('btn-jump');
            const btnDash = document.getElementById('btn-dash');
            const btnPause = document.getElementById('mob-pause-btn');
            
            let startX, startY;
            joyBase.addEventListener('touchstart', (e) => { 
                e.stopPropagation(); 
                if (joyTouchId === -1) {
                    const t = e.changedTouches[0];
                    joyTouchId = t.identifier;
                    startX = t.clientX; 
                    startY = t.clientY;
                }
            }, {passive:false});

            joyBase.addEventListener('touchmove', (e) => {
                e.preventDefault(); e.stopPropagation();
                if (joyTouchId === -1) return;

                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joyTouchId) {
                        const t = e.changedTouches[i];
                        const dx = t.clientX - startX, dy = t.clientY - startY;
                        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 75);
                        const angle = Math.atan2(dy, dx);
                        joyStick.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                        joystick.x = (Math.cos(angle)*dist)/75; joystick.y = -(Math.sin(angle)*dist)/75;
                        break;
                    }
                }
            }, {passive:false});
            
            const resetJoy = (e) => { 
                e.stopPropagation(); 
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joyTouchId) {
                        joyTouchId = -1;
                        joyStick.style.transform = `translate(-50%, -50%)`; 
                        joystick.x=0; joystick.y=0; 
                        break;
                    }
                }
            };
            joyBase.addEventListener('touchend', resetJoy); 
            joyBase.addEventListener('touchcancel', resetJoy);

            let lastLookX, lastLookY, currentTouchId = -1;
            renderer.domElement.addEventListener('touchstart', (e) => {
                if(!isGameRunning || isPaused) return;
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(!t.target.closest('.joy-zone') && !t.target.closest('.mob-btn') && !t.target.closest('.mini-btn')) {
                        if(currentTouchId===-1) { isLooking=true; currentTouchId=t.identifier; lastLookX=t.clientX; lastLookY=t.clientY; break; }
                    }
                }
            }, {passive:false});
            renderer.domElement.addEventListener('touchmove', (e) => {
                if(!isLooking || currentTouchId===-1 || isPaused) return;
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === currentTouchId) {
                        e.preventDefault();
                        const t = e.changedTouches[i];
                        camera.rotation.y -= (t.clientX - lastLookX) * 0.005 * lookSpeed * sensitivity;
                        camera.rotation.x -= (t.clientY - lastLookY) * 0.005 * lookSpeed * sensitivity;
                        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                        lastLookX=t.clientX; lastLookY=t.clientY; break;
                    }
                }
            }, {passive:false});
            const endLook = (e) => { for(let i=0; i<e.changedTouches.length; i++) if(e.changedTouches[i].identifier === currentTouchId) { isLooking=false; currentTouchId=-1; break; } };
            renderer.domElement.addEventListener('touchend', endLook); renderer.domElement.addEventListener('touchcancel', endLook);

            btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); if(canJump && !isPaused) { velocityY=CONFIG.jumpForce; canJump=false; } });
            btnDash.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); if(!isPaused) tryDodge(); });
            btnPause.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); if(isPaused) requestResume(); else requestPause(); });
        }

        function checkFloorPresence(px, pz) {
            const cx = Math.round(px/CONFIG.cellSize), cz = Math.round(pz/CONFIG.cellSize);
            if(cx<0||cx>=mazeWidth||cz<0||cz>=mazeHeight) return false;
            return grid[cz][cx] !== '#' && grid[cz][cx] !== 'H';
        }

        function tryDodge() {
            if (dashCharges > 0 && !isDodging) {
                isDodging = true; dodgeTimer = CONFIG.dodgeDuration; dashTimer = CONFIG.dashTime;
                dashCharges--;
                updateDashUI();
                
                if (dashCharges === (CONFIG.maxDashCharges - 1)) {
                    dashRechargeTimer = CONFIG.dashRechargeTime;
                }
                
                document.body.classList.add('phasing'); 
                
                const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y=0; fwd.normalize();
                const rgt = new THREE.Vector3().crossVectors(fwd, camera.up);
                let ix, iz;
                if(isMobile || gamepadIndex!==null) { ix=joystick.x; iz=joystick.y; }
                else { ix=Number(moveRight)-Number(moveLeft); iz=Number(moveForward)-Number(moveBackward); }
                
                const td = new THREE.Vector3(ix,0,iz).normalize();
                dashVector.set(0,0,0);
                if(td.length()>0.1) { dashVector.addScaledVector(fwd, td.z); dashVector.addScaledVector(rgt, td.x); dashVector.normalize().multiplyScalar(CONFIG.dashForce); }
                else dashVector.copy(fwd).multiplyScalar(CONFIG.dashForce);
            }
        }

        function updateEnvironment(lvl) {
            const h = (lvl*0.15)%1.0; scene.background = new THREE.Color().setHSL(h,0.6,0.05);
            scene.fog = new THREE.FogExp2(new THREE.Color().setHSL(h,0.6,0.1), 0.08);
            const old = scene.getObjectByName("SkyPoints"); if(old) scene.remove(old);
            if(!lowGraphics) {
                const geo = new THREE.BufferGeometry(); const pos = new Float32Array(1500);
                for(let i=0;i<1500;i++) pos[i]=(Math.random()-0.5)*100;
                geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
                const stars = new THREE.Points(geo, new THREE.PointsMaterial({color:0xffffff, size:0.2, transparent:true, opacity:0.6}));
                stars.name="SkyPoints"; scene.add(stars);
            }
        }

        function regenerateLevel() {
            walls.forEach(w=>scene.remove(w)); walls=[];
            enemies.forEach(e=>scene.remove(e.mesh)); enemies=[];
            if(goalObj) scene.remove(goalObj);

            updateEnvironment(level);
            
            // Randomly increase size slightly every 5 levels
            const baseSize = 13 + Math.floor(level / 5) * 4;
            grid = createRandomMaze(baseSize, baseSize);
            
            mazeHeight = grid.length;
            mazeWidth = grid[0].length;

            const wMat = new THREE.MeshStandardMaterial({ map: generateTexture('#000','brick'), roughness:0.2, metalness:0.8, emissive:0x000505 });
            const fMat = new THREE.MeshStandardMaterial({ map: generateTexture('#000','grid'), roughness:0.5, metalness:0.5, side:THREE.DoubleSide });
            const ceil = new THREE.Mesh(new THREE.PlaneGeometry(mazeWidth*CONFIG.cellSize, mazeHeight*CONFIG.cellSize), new THREE.MeshBasicMaterial({color:0x000000}));
            ceil.rotation.x=Math.PI/2; ceil.position.set((mazeWidth*CONFIG.cellSize)/2-CONFIG.cellSize/2, CONFIG.wallHeight, (mazeHeight*CONFIG.cellSize)/2-CONFIG.cellSize/2);
            scene.add(ceil);

            const boxG = new THREE.BoxGeometry(CONFIG.cellSize, CONFIG.wallHeight, CONFIG.cellSize);
            const enGeo = new THREE.IcosahedronGeometry(0.5, 0); const enMat = new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xaa0000, wireframe:true});

            for(let y=0;y<mazeHeight;y++) for(let x=0;x<mazeWidth;x++) {
                let t = grid[y][x]; 
                const px=x*CONFIG.cellSize, pz=y*CONFIG.cellSize;
                
                // Randomly spawn enemy in empty spots if lvl >= 5
                if (level >= 5 && t === '.' && Math.random() < 0.05) {
                    t = 'E';
                }

                if(t==='#') {
                    const w = new THREE.Mesh(boxG, wMat); w.position.set(px, CONFIG.wallHeight/2, pz);
                    w.castShadow=!lowGraphics; w.receiveShadow=!lowGraphics; w.userData.bbox = new THREE.Box3().setFromObject(w); walls.push(w); scene.add(w);
                } 
                else {
                    if(t !== 'H') {
                        const f = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.cellSize, CONFIG.cellSize).rotateX(-Math.PI/2), fMat);
                        f.position.set(px,0,pz); f.receiveShadow=!lowGraphics; walls.push(f); scene.add(f);
                    }
                    
                    if(t==='P') {
                        camera.position.set(px, defaultCameraHeight, pz);
                        // Orient player
                        if(y > 0 && grid[y-1][x] !== '#') camera.rotation.y = Math.PI;
                        else if(y < mazeHeight - 1 && grid[y+1][x] !== '#') camera.rotation.y = 0;
                        else if(x < mazeWidth - 1 && grid[y][x+1] !== '#') camera.rotation.y = -Math.PI / 2;
                        else if(x > 0 && grid[y][x-1] !== '#') camera.rotation.y = Math.PI / 2;
                    }
                    else if(t==='G') {
                        goalObj = new THREE.Mesh(new THREE.IcosahedronGeometry(CONFIG.cellSize*0.3, 1), new THREE.MeshStandardMaterial({color:0x00ffff, emissive:0x0088aa, wireframe:true, transparent:true, opacity:0.8}));
                        goalObj.position.set(px, CONFIG.wallHeight/2, pz); goalObj.add(new THREE.PointLight(0x00ffff, 3, 8)); scene.add(goalObj);
                    } else if(t==='E') {
                        const en = new THREE.Mesh(enGeo, enMat); en.position.set(px, 1.5, pz);
                        en.add(new THREE.Mesh(new THREE.IcosahedronGeometry(0.2,0), new THREE.MeshBasicMaterial({color:0xffffff})));
                        if(!lowGraphics) en.add(new THREE.PointLight(0xff0000, 3, 6));
                        enemies.push({ 
                            mesh: en, 
                            state: 'SPAWNING', 
                            timer: 1.0, 
                            targetPos: new THREE.Vector3(px, 1.5, pz),
                            lastKnownPlayerPos: new THREE.Vector3(),
                            memoryTimer: 0
                        });
                        scene.add(en);
                    }
                }
            }
            document.getElementById('level-display').innerText = `ZONE: ${level}`;
            
            // --- MINIMAP DEV TOGGLE LOGIC ---
            const mmCont = document.getElementById('minimap-container');
            if (CONFIG.DEV_SHOW_MINIMAP || level >= 15) { 
                mmCont.style.display = 'block'; 
            } else { 
                mmCont.style.display = 'none'; 
            }
        }
        
        function animate(time) {
            requestAnimationFrame(animate);
            if (isPaused) return;

            const delta = Math.min((time - prevTime) / 1000, 0.05);

            if (isGameRunning && (controls.isLocked || isMobile || gamepadIndex !== null)) {
                handleGamepadInput(delta);
                
                if (isMobile || gamepadIndex !== null) { direction.z = joystick.y; direction.x = joystick.x; }
                else { direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft); }
                direction.normalize();

                const moveVec = new THREE.Vector3();
                if (dashTimer > 0) { dashTimer -= delta; moveVec.copy(dashVector).multiplyScalar(delta); }
                else {
                    const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y=0; fwd.normalize();
                    const rgt = new THREE.Vector3().crossVectors(fwd, camera.up);
                    if(direction.length()>0.1) {
                        const mz = direction.z * CONFIG.walkSpeed * delta, mx = direction.x * CONFIG.walkSpeed * delta;
                        moveVec.addScaledVector(fwd, mz).addScaledVector(rgt, mx);
                    }
                }
                
                velocityY -= CONFIG.gravity * delta; 
                camera.position.y += velocityY * delta; 
                
                if (checkFloorPresence(camera.position.x, camera.position.z)) {
                    if (camera.position.y < defaultCameraHeight) { 
                        camera.position.y = defaultCameraHeight; 
                        velocityY = 0; 
                        canJump = true; 
                    }
                } else {
                    canJump = false;
                    if (camera.position.y < CONFIG.FALL_HEIGHT) { 
                        level=1; 
                        regenerateLevel(); 
                        return; 
                    }
                }
                
                const cur = camera.position.clone();
                camera.position.x += moveVec.x;
                playerCollider.setFromCenterAndSize(new THREE.Vector3(camera.position.x, cur.y-0.8, cur.z), new THREE.Vector3(0.8, defaultCameraHeight, 0.8));
                for(const w of walls) if(w.geometry.type==='BoxGeometry' && playerCollider.intersectsBox(w.userData.bbox)) { camera.position.x -= moveVec.x; break; }

                camera.position.z += moveVec.z;
                playerCollider.setFromCenterAndSize(new THREE.Vector3(camera.position.x, cur.y-0.8, camera.position.z), new THREE.Vector3(0.8, defaultCameraHeight, 0.8));
                for(const w of walls) if(w.geometry.type==='BoxGeometry' && playerCollider.intersectsBox(w.userData.bbox)) { camera.position.z -= moveVec.z; break; }

                if (isDodging) { dodgeTimer -= delta; if(dodgeTimer<=0) { isDodging=false; document.body.classList.remove('phasing'); } }
                
                if (dashCharges < CONFIG.maxDashCharges) {
                    dashRechargeTimer -= delta;
                    
                    if (dashRechargeTimer <= 0) {
                        dashCharges++;
                        if (dashCharges < CONFIG.maxDashCharges) {
                            dashRechargeTimer = CONFIG.dashRechargeTime;
                        } else {
                            dashRechargeTimer = 0;
                        }
                    }
                    updateDashUI();
                }

                if (direction.length() > 0.1) { bobTimer += delta * CONFIG.viewBobSpeed; if (canJump) camera.position.y = defaultCameraHeight + Math.sin(bobTimer) * CONFIG.viewBobHeight; }
                else bobTimer = 0;

                updateEnemies(delta);

                if (goalObj && playerCollider.intersectsBox(new THREE.Box3().setFromObject(goalObj))) {
                    level++; if(level>highScore) { highScore=level; localStorage.setItem('protoMazeHighScore', highScore); document.getElementById('highscore-display').innerText = `HIGH: ZONE ${highScore}`; }
                    regenerateLevel(); return;
                }
            }

            if (goalObj) { goalObj.rotation.x += delta * 0.2; goalObj.rotation.y += delta * 0.5; }

            if (isGameRunning) document.getElementById('timer-display').innerText = `TIME: ${formatTime(Math.floor(performance.now() - gameStartTime))}`;

            if (CONFIG.DEV_SHOW_MINIMAP || level >= 15) {
                minimapCtx.fillStyle = '#001122'; minimapCtx.fillRect(0,0,150,150);
                const s = 150/(Math.max(mazeWidth,mazeHeight)*CONFIG.cellSize);
                walls.forEach(w=>{ minimapCtx.fillStyle=w.geometry.type==='BoxGeometry'?'#00f3ff':'#004455'; minimapCtx.fillRect(w.position.x*s-CONFIG.cellSize*s/2, w.position.z*s-CONFIG.cellSize*s/2, CONFIG.cellSize*s, CONFIG.cellSize*s); });
                minimapCtx.fillStyle='#ff0040'; minimapCtx.fillRect(camera.position.x*s-2, camera.position.z*s-2, 4, 4);
                
                if(goalObj) {
                    minimapCtx.fillStyle='#00ff00';
                    minimapCtx.fillRect(goalObj.position.x*s-3, goalObj.position.z*s-3, 6, 6);
                }
                
                enemies.forEach(e => {
                    minimapCtx.fillStyle='#ff0000';
                    minimapCtx.beginPath();
                    minimapCtx.arc(e.mesh.position.x*s, e.mesh.position.z*s, 3, 0, Math.PI*2);
                    minimapCtx.fill();
                });
            }
            renderer.render(scene, camera);
            prevTime = time;
        }

        function updateEnemies(delta) {
            const playerPos = camera.position.clone();
            const speed = 3.5;

            enemies.forEach(e => {
                if (e.state === 'SPAWNING') {
                    e.timer -= delta;
                    if (e.timer <= 0) {
                        e.state = 'IDLE';
                        e.timer = 2.0 + Math.random();
                    }
                    return;
                }
                
                const distToPlayer = e.mesh.position.distanceTo(playerPos);
                const gridX = Math.round(e.mesh.position.x / CONFIG.cellSize);
                const gridZ = Math.round(e.mesh.position.z / CONFIG.cellSize);
                
                let visible = false;
                if (distToPlayer < 15) { 
                    const dir = playerPos.clone().sub(e.mesh.position).normalize();
                    const raycaster = new THREE.Raycaster(e.mesh.position, dir, 0, distToPlayer);
                    const hits = raycaster.intersectObjects(walls);
                    if (hits.length === 0) visible = true; 
                }

                if (visible) {
                    e.state = 'CHASE';
                    e.memoryTimer = 0.5;
                    e.lastKnownPlayerPos.copy(playerPos);
                } else if (e.memoryTimer > 0) {
                    e.state = 'SEARCHING';
                    e.memoryTimer -= delta;
                } else {
                    e.state = 'IDLE';
                }

                let target = null;
                if (e.state === 'CHASE' || e.state === 'SEARCHING') {
                    target = e.lastKnownPlayerPos;
                } else {
                    if (e.mesh.position.distanceTo(e.targetPos) < 0.5 || e.timer <= 0) {
                        e.timer = 2.0 + Math.random();
                        const dirs = [{x:1,z:0}, {x:-1,z:0}, {x:0,z:1}, {x:0,z:-1}];
                        const d = dirs[Math.floor(Math.random()*dirs.length)];
                        const nx = gridX + d.x; const nz = gridZ + d.z;
                        if (nx>=0 && nx<mazeWidth && nz>=0 && nz<mazeHeight && grid[nz][nx] !== '#') {
                            e.targetPos.set(nx*CONFIG.cellSize, 1.5, nz*CONFIG.cellSize);
                        }
                    }
                    target = e.targetPos;
                    e.timer -= delta;
                }

                const moveDir = target.clone().sub(e.mesh.position);
                moveDir.y = 0; 
                if (moveDir.length() > 0.1) {
                    moveDir.normalize();
                    const step = moveDir.multiplyScalar(speed * delta);
                    
                    const nextX = e.mesh.position.x + step.x;
                    const nextZ = e.mesh.position.z + step.z;
                    
                    const checkX = Math.round(nextX / CONFIG.cellSize);
                    const checkZ = Math.round(e.mesh.position.z / CONFIG.cellSize);
                    if(checkX>=0 && checkX<mazeWidth && checkZ>=0 && checkZ<mazeHeight && grid[checkZ][checkX]!=='#') {
                        e.mesh.position.x = nextX;
                    }

                    const checkZ2 = Math.round(nextZ / CONFIG.cellSize);
                    const checkX2 = Math.round(e.mesh.position.x / CONFIG.cellSize);
                    if(checkZ2>=0 && checkZ2<mazeHeight && checkX2>=0 && checkX2<mazeWidth && grid[checkZ2][checkX2]!=='#') {
                        e.mesh.position.z = nextZ;
                    }
                    
                    e.mesh.lookAt(e.mesh.position.clone().add(moveDir));
                }

                if (distToPlayer < 0.8 && !isDodging) {
                    level = 1; regenerateLevel();
                }
            });
        }
    </script>
</body>
</html>
